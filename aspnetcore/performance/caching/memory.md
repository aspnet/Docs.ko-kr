---
title: ASP.NET Core 메모리 내 캐시
author: rick-anderson
description: ASP.NET Core에서 데이터를 메모리에 캐시하는 방법을 알아봅니다.
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- appsettings.json
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: d71678aeee9b3fca717129a2fbed1f75b593e010
ms.sourcegitcommit: 54fe1ae5e7d068e27376d562183ef9ddc7afc432
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/10/2021
ms.locfileid: "102586308"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="4ac28-103">ASP.NET Core 메모리 내 캐시</span><span class="sxs-lookup"><span data-stu-id="4ac28-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="4ac28-104">작성자, [Rick Anderson](https://twitter.com/RickAndMSFT), [John 루 오 어](https://github.com/JunTaoLuo)및 [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="4ac28-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="4ac28-105">[예제 코드 살펴보기 및 다운로드](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/3.0sample) ([다운로드 방법](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="4ac28-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="4ac28-106">캐싱 기본 사항</span><span class="sxs-lookup"><span data-stu-id="4ac28-106">Caching basics</span></span>

<span data-ttu-id="4ac28-107">캐싱은 콘텐츠를 생성 하는 데 필요한 작업을 줄여 응용 프로그램의 성능과 확장성을 크게 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="4ac28-108">캐싱은 자주 변경 되지 **않으며** 생성 하는 데 비용이 많이 드는 데이터에서 가장 잘 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="4ac28-109">캐싱은 원본에서 보다 훨씬 빠르게 반환 될 수 있는 데이터 복사본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="4ac28-110">캐시 된 데이터에 종속 **되지 않도록** 앱을 작성 하 고 테스트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="4ac28-111">ASP.NET Core는 여러 캐시를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="4ac28-112">가장 간단한 캐시는 [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache)을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="4ac28-113">`IMemoryCache` 웹 서버의 메모리에 저장 된 캐시를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="4ac28-114">서버 팜 (여러 서버)에서 실행 되는 앱은 메모리 내 캐시를 사용할 때 세션이 고정 되어 있는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="4ac28-115">고정 세션은 클라이언트의 후속 요청이 모두 동일한 서버로 이동 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="4ac28-116">예를 들어 Azure Web apps는 ARR ( [응용 프로그램 요청 라우팅](https://www.iis.net/learn/extensions/planning-for-arr) )을 사용 하 여 모든 후속 요청을 동일한 서버에 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="4ac28-117">웹 팜의 고정 되지 않은 세션은 캐시 일관성 문제를 방지 하기 위해 [분산 캐시가](distributed.md) 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="4ac28-118">일부 앱의 경우 분산 캐시는 메모리 내 캐시 보다 더 높은 확장을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="4ac28-119">분산 캐시를 사용 하면 캐시 메모리가 외부 프로세스로 오프 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="4ac28-120">메모리 내 캐시는 모든 개체를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="4ac28-121">분산 캐시 인터페이스는로 제한 됩니다 `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="4ac28-122">메모리 내 및 분산 캐시 저장소는 키-값 쌍으로 항목을 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="4ac28-123">시스템 런타임 캐싱/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="4ac28-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="4ac28-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet 패키지](https://www.nuget.org/packages/System.Runtime.Caching/))는와 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="4ac28-125">2.0 이상 .NET Standard 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="4ac28-126">.NET Standard 2.0 이상을 대상으로 하는 [.net 구현](/dotnet/standard/net-standard#net-implementation-support)</span><span class="sxs-lookup"><span data-stu-id="4ac28-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="4ac28-127">예를 들어 ASP.NET Core 2.0 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="4ac28-128">.NET Framework 4.5 이상</span><span class="sxs-lookup"><span data-stu-id="4ac28-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="4ac28-129">[](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` 이 문서에 설명 된 대로, `System.Runtime.Caching` / `MemoryCache` ASP.NET Core에 더 잘 통합 되기 때문에이 문서에 설명 되어 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="4ac28-130">예를 들어은 `IMemoryCache` ASP.NET Core [종속성 주입](xref:fundamentals/dependency-injection)을 기본적으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="4ac28-131">`System.Runtime.Caching` / `MemoryCache` ASP.NET 4.x에서 ASP.NET Core로 코드를 이식할 때 호환성 브리지로를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="4ac28-132">캐시 지침</span><span class="sxs-lookup"><span data-stu-id="4ac28-132">Cache guidelines</span></span>

* <span data-ttu-id="4ac28-133">코드에는 항상 데이터를 인출 하는 대체 (fallback) 옵션이 있으며 사용 가능한 캐시 된 값에 의존 **하지** 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="4ac28-134">캐시는 부족 한 리소스 인 메모리를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="4ac28-135">캐시 증가 제한:</span><span class="sxs-lookup"><span data-stu-id="4ac28-135">Limit cache growth:</span></span>
  * <span data-ttu-id="4ac28-136">외부 입력을 캐시 키로 사용 **하지** 마십시오.</span><span class="sxs-lookup"><span data-stu-id="4ac28-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="4ac28-137">캐시 증가를 제한 하려면 만료를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="4ac28-138">[SetSize, Size 및 SizeLimit를 사용 하 여 캐시 크기를 제한](#use-setsize-size-and-sizelimit-to-limit-cache-size)합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="4ac28-139">ASP.NET Core 런타임은 메모리 압력에 따라 캐시 크기를 제한 **하지** 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="4ac28-140">캐시 크기를 제한 하는 것은 개발자에 게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="4ac28-141">IMemoryCache 사용</span><span class="sxs-lookup"><span data-stu-id="4ac28-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="4ac28-142">[종속성 주입](xref:fundamentals/dependency-injection) 에서 *공유* 메모리 캐시를 사용 하 고, 또는를 호출 하 여 `SetSize` `Size` `SizeLimit` 캐시 크기를 제한 하면 앱에 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="4ac28-143">캐시에 크기 제한이 설정 된 경우 모든 항목은 추가 될 때 크기를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="4ac28-144">이로 인해 개발자가 공유 캐시를 사용 하는 항목을 완전히 제어할 수 없기 때문에 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="4ac28-145">예를 들어 Entity Framework Core는 공유 캐시를 사용 하 고 크기를 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="4ac28-146">앱이 캐시 크기 제한을 설정 하 고 EF Core를 사용 하는 경우 앱은을 throw `InvalidOperationException` 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="4ac28-147">, 또는를 사용 하 여 `SetSize` `Size` `SizeLimit` 캐시를 제한 하는 경우 캐싱에 대 한 캐시 singleton을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="4ac28-148">자세한 내용 및 예제는 [SetSize, Size 및 SizeLimit를 사용 하 여 캐시 크기 제한](#use-setsize-size-and-sizelimit-to-limit-cache-size)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ac28-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="4ac28-149">공유 캐시는 다른 프레임 워크 또는 라이브러리에서 공유 하는 캐시입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="4ac28-150">예를 들어 EF Core는 공유 캐시를 사용 하 고 크기를 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="4ac28-151">메모리 내 캐싱은 [종속성 주입](xref:fundamentals/dependency-injection)을 사용 하 여 앱에서 참조 되는 *서비스* 입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="4ac28-152">`IMemoryCache`생성자에서 인스턴스를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="4ac28-153">다음 코드에서는 [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) 를 사용 하 여 시간이 캐시에 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="4ac28-154">시간이 캐시 되지 않으면 새 항목이 만들어지고 [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_)을 사용 하 여 캐시에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="4ac28-155">`CacheKeys`클래스는 다운로드 샘플의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="4ac28-156">현재 시간과 캐시 된 시간이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="4ac28-157">다음 코드에서는 [집합](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_System_TimeSpan_) 확장명 메서드를 사용 하 여 개체를 만들지 않고 상대 시간에 대 한 데이터를 캐시 합니다 `MemoryCacheEntryOptions` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-157">The following code uses the [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_System_TimeSpan_) extension method to cache data for a relative time without creating the `MemoryCacheEntryOptions` object.</span></span>
[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_set)]

<span data-ttu-id="4ac28-158">`DateTime`제한 시간 내에 요청이 있는 동안 캐시 된 값은 캐시에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-158">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="4ac28-159">다음 코드는 [Getorcreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) 및 [Getorcreateasync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) 를 사용 하 여 데이터를 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-159">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="4ac28-160">다음 코드는 [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) 을 호출 하 여 캐시 된 시간을 인출 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-160">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="4ac28-161">다음 코드는 절대 만료를 사용 하는 캐시 된 항목을 가져오거나 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-161">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="4ac28-162">슬라이딩 만료가 있는 캐시 된 항목 집합은 부실 해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-162">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="4ac28-163">슬라이딩 만료 간격 보다 더 자주 액세스 하는 경우 항목은 만료 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-163">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="4ac28-164">절대 만료 시간이 지날 때 항목이 만료 되도록 하려면 슬라이딩 만료를 절대 만료와 결합 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-164">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="4ac28-165">절대 만료는 항목을 캐시할 수 있는 기간에 대 한 상한을 설정 하 고, 해당 항목이 슬라이딩 만료 간격 내에 요청 되지 않은 경우에도 이전에 만료 될 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-165">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="4ac28-166">절대 및 상대 (sliding) 만료가 모두 지정 된 경우 만료는 논리적으로 ORed 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-166">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="4ac28-167">슬라이딩 만료 간격이 *나* 절대 만료 시간을 전달 하는 경우 항목은 캐시에서 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-167">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="4ac28-168">다음 코드는 슬라이딩 *및* 절대 만료를 모두 사용 하 여 캐시 된 항목을 가져오거나 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-168">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="4ac28-169">위의 코드는 데이터가 절대 시간 보다 오래 캐시 되지 않도록 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-169">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="4ac28-170"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> 및 <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> 는 클래스의 확장 메서드입니다 <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> .</span><span class="sxs-lookup"><span data-stu-id="4ac28-170"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="4ac28-171">이러한 메서드는의 기능을 확장 <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-171">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="4ac28-172">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="4ac28-172">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="4ac28-173">다음 샘플입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-173">The following sample:</span></span>

* <span data-ttu-id="4ac28-174">슬라이딩 만료 시간을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-174">Sets a sliding expiration time.</span></span> <span data-ttu-id="4ac28-175">이 캐시 된 항목에 액세스 하는 요청은 슬라이딩 만료 시간을 다시 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-175">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="4ac28-176">캐시 우선 순위를 [Cacheitempriority. NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove)로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-176">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="4ac28-177">항목이 캐시에서 제거 된 후에 호출 되는 [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) 을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-177">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="4ac28-178">콜백은 캐시에서 항목을 제거 하는 코드와 다른 스레드에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-178">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="4ac28-179">SetSize, Size 및 SizeLimit를 사용 하 여 캐시 크기 제한</span><span class="sxs-lookup"><span data-stu-id="4ac28-179">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="4ac28-180">`MemoryCache`인스턴스는 필요에 따라 크기 제한을 지정 하 고 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-180">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="4ac28-181">캐시 크기 제한에는 항목의 크기를 측정 하는 메커니즘이 없기 때문에 정의 된 측정 단위가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-181">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="4ac28-182">캐시 크기 제한이 설정 된 경우 모든 항목의 크기를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-182">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="4ac28-183">ASP.NET Core 런타임은 메모리 압력에 따라 캐시 크기를 제한 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-183">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="4ac28-184">캐시 크기를 제한 하는 것은 개발자에 게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-184">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="4ac28-185">지정 된 크기는 개발자가 선택 하는 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-185">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="4ac28-186">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-186">For example:</span></span>

* <span data-ttu-id="4ac28-187">웹 앱이 주로 문자열을 캐싱하는 경우 각 캐시 엔트리 크기는 문자열 길이가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-187">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="4ac28-188">앱은 모든 항목의 크기를 1로 지정 하 고, 크기 제한은 항목 수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-188">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="4ac28-189"><xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit>가 설정 되지 않은 경우 캐시는 바인딩되지 않고 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-189">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="4ac28-190">시스템 메모리가 부족할 때 ASP.NET Core 런타임은 캐시를 자르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-190">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="4ac28-191">앱은 다음을 위해 설계 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-191">Apps must be architected to:</span></span>

* <span data-ttu-id="4ac28-192">캐시 증가를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-192">Limit cache growth.</span></span>
* <span data-ttu-id="4ac28-193"><xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*>또는 <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> 사용 가능한 메모리가 제한 된 경우를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-193">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="4ac28-194">다음 코드는 <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> [종속성 주입](xref:fundamentals/dependency-injection)을 통해 액세스할 수 있는 고정 크기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-194">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="4ac28-195">`SizeLimit` 에 단위가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-195">`SizeLimit` does not have units.</span></span> <span data-ttu-id="4ac28-196">캐시 된 항목은 캐시 크기 한도가 설정 된 경우 가장 적합 한 모든 단위에서 크기를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-196">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="4ac28-197">캐시 인스턴스의 모든 사용자는 동일한 단위 시스템을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-197">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="4ac28-198">캐시 된 항목 크기의 합계가에 지정 된 값을 초과 하는 경우 항목이 캐시 되지 않습니다 `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-198">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="4ac28-199">캐시 크기 제한을 설정 하지 않으면 항목에 설정 된 캐시 크기가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-199">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="4ac28-200">다음 코드는 `MyMemoryCache` [종속성 주입](xref:fundamentals/dependency-injection) 컨테이너에 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-200">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="4ac28-201">`MyMemoryCache` 는이 크기 제한 된 캐시를 인식 하는 구성 요소에 대 한 독립 메모리 캐시로 만들어지며 캐시 엔트리 크기를 적절 하 게 설정 하는 방법을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-201">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="4ac28-202">다음 코드에서는를 사용 합니다 `MyMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-202">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="4ac28-203">캐시 엔트리의 크기는 <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> 또는 확장 메서드를 통해 설정할 수 있습니다 <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> .</span><span class="sxs-lookup"><span data-stu-id="4ac28-203">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="4ac28-204">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="4ac28-204">MemoryCache.Compact</span></span>

<span data-ttu-id="4ac28-205">`MemoryCache.Compact` 다음 순서에 따라 캐시의 지정 된 비율을 제거 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-205">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="4ac28-206">만료 된 모든 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-206">All expired items.</span></span>
* <span data-ttu-id="4ac28-207">우선 순위별로 항목</span><span class="sxs-lookup"><span data-stu-id="4ac28-207">Items by priority.</span></span> <span data-ttu-id="4ac28-208">우선 순위가 가장 낮은 항목이 먼저 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-208">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="4ac28-209">가장 최근에 사용한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-209">Least recently used objects.</span></span>
* <span data-ttu-id="4ac28-210">가장 빠른 절대 만료를 가진 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-210">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="4ac28-211">가장 빠른 슬라이딩 만료를 포함 하는 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-211">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="4ac28-212">우선 순위가 있는 고정 된 항목 <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> 은 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-212">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="4ac28-213">다음 코드는 캐시 항목을 제거 하 고를 호출 합니다 `Compact` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-213">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="4ac28-214">자세한 내용은 [GitHub의 Compact source](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ac28-214">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="4ac28-215">캐시 종속성</span><span class="sxs-lookup"><span data-stu-id="4ac28-215">Cache dependencies</span></span>

<span data-ttu-id="4ac28-216">다음 샘플에서는 종속 항목이 만료 된 경우 캐시 항목을 만료 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-216">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="4ac28-217"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>이 캐시 된 항목에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-217">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="4ac28-218">`Cancel`에 대해를 호출 하면 `CancellationTokenSource` 두 캐시 항목이 모두 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-218">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="4ac28-219">를 사용 <xref:System.Threading.CancellationTokenSource> 하면 여러 캐시 항목을 하나의 그룹으로 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-219">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="4ac28-220">`using`위의 코드에서 패턴을 사용 하 여 블록 내에 만들어진 캐시 항목 `using` 은 트리거와 만료 설정을 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-220">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="4ac28-221">추가 참고 사항</span><span class="sxs-lookup"><span data-stu-id="4ac28-221">Additional notes</span></span>

* <span data-ttu-id="4ac28-222">만료는 백그라운드에서 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-222">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="4ac28-223">만료 된 항목에 대 한 캐시를 적극적으로 검색 하는 타이머가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-223">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="4ac28-224">캐시의 모든 작업 ( `Get` , `Set` ,)은 만료 된 `Remove` 항목에 대 한 백그라운드 검색을 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-224">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="4ac28-225">`CancellationTokenSource`또한 ()의 타이머는 <xref:System.Threading.CancellationTokenSource.CancelAfter*> 항목을 제거 하 고 만료 된 항목에 대 한 검색을 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-225">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and triggers a scan for expired items.</span></span> <span data-ttu-id="4ac28-226">다음 예에서는 등록 된 토큰에 대해 [CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) 을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-226">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="4ac28-227">이 토큰이 발생 하면 엔트리를 즉시 제거 하 고 제거 콜백을 발생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-227">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="4ac28-228">콜백을 사용 하 여 캐시 항목을 다시 채우는 경우:</span><span class="sxs-lookup"><span data-stu-id="4ac28-228">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="4ac28-229">콜백이 완료 되지 않아 여러 요청에서 캐시 된 키 값이 비어 있는 것을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-229">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="4ac28-230">이로 인해 여러 스레드가 캐시 된 항목을 늘이기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-230">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="4ac28-231">한 캐시 엔트리를 사용 하 여 다른 캐시 엔트리를 만드는 경우 자식는 부모 항목의 만료 토큰 및 시간 기반 만료 설정을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-231">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="4ac28-232">자식은 수동으로 제거 하거나 부모 항목을 업데이트 하 여 만료 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-232">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="4ac28-233">캐시 <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> 엔트리를 캐시에서 제거한 후에 발생 하는 콜백을 설정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-233">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="4ac28-234">대부분의 앱에서 `IMemoryCache` 이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-234">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="4ac28-235">예를 들어,,, `AddMvc` `AddControllersWithViews` `AddRazorPages` `AddMvcCore().AddRazorViewEngine` 및의 다른 여러 메서드를 호출 하면 `Add{Service}` `ConfigureServices` 가 활성화 `IMemoryCache` 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-235">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="4ac28-236">이전 메서드 중 하나를 호출 하지 않는 앱의 경우 `Add{Service}` 에서를 호출 해야 할 수 있습니다 <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> `ConfigureServices` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-236">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="4ac28-237">백그라운드 캐시 업데이트</span><span class="sxs-lookup"><span data-stu-id="4ac28-237">Background cache update</span></span>

<span data-ttu-id="4ac28-238">과 같은 [백그라운드 서비스](xref:fundamentals/host/hosted-services) 를 사용 <xref:Microsoft.Extensions.Hosting.IHostedService> 하 여 캐시를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-238">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="4ac28-239">백그라운드 서비스는 항목을 다시 계산 하 고 준비 된 경우에만 캐시에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-239">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="4ac28-240">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="4ac28-240">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="4ac28-241">작성자, [Rick Anderson](https://twitter.com/RickAndMSFT), [John 루 오 어](https://github.com/JunTaoLuo)및 [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="4ac28-241">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="4ac28-242">[예제 코드 살펴보기 및 다운로드](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/sample) ([다운로드 방법](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="4ac28-242">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="4ac28-243">캐싱 기본 사항</span><span class="sxs-lookup"><span data-stu-id="4ac28-243">Caching basics</span></span>

<span data-ttu-id="4ac28-244">캐싱은 콘텐츠를 생성 하는 데 필요한 작업을 줄여 응용 프로그램의 성능과 확장성을 크게 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-244">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="4ac28-245">캐싱은 자주 변경 되지 않는 데이터에 가장 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-245">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="4ac28-246">캐싱은 원래 원본에서 보다 훨씬 빠르게 반환 될 수 있는 데이터 복사본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-246">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="4ac28-247">캐시 된 데이터에 종속 **되지 않도록** 코드를 작성 하 고 테스트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-247">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="4ac28-248">ASP.NET Core는 여러 캐시를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-248">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="4ac28-249">가장 간단한 캐시는 웹 서버의 메모리에 저장 된 캐시를 나타내는 [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache)을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-249">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="4ac28-250">서버 팜 (여러 서버)에서 실행 되는 앱은 메모리 내 캐시를 사용할 때 세션이 고정 되어 있는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-250">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="4ac28-251">고정 세션은 클라이언트의 이후 요청이 모두 동일한 서버로 이동 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-251">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="4ac28-252">예를 들어 Azure Web apps는 ARR ( [응용 프로그램 요청 라우팅](https://www.iis.net/learn/extensions/planning-for-arr) )을 사용 하 여 사용자 에이전트의 모든 요청을 동일한 서버로 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-252">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="4ac28-253">웹 팜의 고정 되지 않은 세션은 캐시 일관성 문제를 방지 하기 위해 [분산 캐시가](distributed.md) 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-253">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="4ac28-254">일부 앱의 경우 분산 캐시는 메모리 내 캐시 보다 더 높은 확장을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-254">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="4ac28-255">분산 캐시를 사용 하면 캐시 메모리가 외부 프로세스로 오프 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-255">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="4ac28-256">메모리 내 캐시는 모든 개체를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-256">The in-memory cache can store any object.</span></span> <span data-ttu-id="4ac28-257">분산 캐시 인터페이스는로 제한 됩니다 `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-257">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="4ac28-258">메모리 내 및 분산 캐시 저장소는 키-값 쌍으로 항목을 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-258">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="4ac28-259">시스템 런타임 캐싱/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="4ac28-259">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="4ac28-260"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet 패키지](https://www.nuget.org/packages/System.Runtime.Caching/))는와 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-260"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="4ac28-261">2.0 이상 .NET Standard 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-261">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="4ac28-262">.NET Standard 2.0 이상을 대상으로 하는 [.net 구현](/dotnet/standard/net-standard#net-implementation-support)</span><span class="sxs-lookup"><span data-stu-id="4ac28-262">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="4ac28-263">예를 들어 ASP.NET Core 2.0 이상입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-263">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="4ac28-264">.NET Framework 4.5 이상</span><span class="sxs-lookup"><span data-stu-id="4ac28-264">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="4ac28-265">[](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` 이 문서에 설명 된 대로, `System.Runtime.Caching` / `MemoryCache` ASP.NET Core에 더 잘 통합 되기 때문에이 문서에 설명 되어 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-265">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="4ac28-266">예를 들어은 `IMemoryCache` ASP.NET Core [종속성 주입](xref:fundamentals/dependency-injection)을 기본적으로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-266">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="4ac28-267">`System.Runtime.Caching` / `MemoryCache` ASP.NET 4.x에서 ASP.NET Core로 코드를 이식할 때 호환성 브리지로를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-267">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="4ac28-268">캐시 지침</span><span class="sxs-lookup"><span data-stu-id="4ac28-268">Cache guidelines</span></span>

* <span data-ttu-id="4ac28-269">코드에는 항상 데이터를 인출 하는 대체 (fallback) 옵션이 있으며 사용 가능한 캐시 된 값에 의존 **하지** 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-269">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="4ac28-270">캐시는 부족 한 리소스 인 메모리를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-270">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="4ac28-271">캐시 증가 제한:</span><span class="sxs-lookup"><span data-stu-id="4ac28-271">Limit cache growth:</span></span>
  * <span data-ttu-id="4ac28-272">외부 입력을 캐시 키로 사용 **하지** 마십시오.</span><span class="sxs-lookup"><span data-stu-id="4ac28-272">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="4ac28-273">캐시 증가를 제한 하려면 만료를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-273">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="4ac28-274">[SetSize, Size 및 SizeLimit를 사용 하 여 캐시 크기를 제한](#use-setsize-size-and-sizelimit-to-limit-cache-size)합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-274">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="4ac28-275">ASP.NET Core 런타임은 메모리 압력에 따라 캐시 크기를 제한 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-275">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="4ac28-276">캐시 크기를 제한 하는 것은 개발자에 게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-276">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="4ac28-277">IMemoryCache 사용</span><span class="sxs-lookup"><span data-stu-id="4ac28-277">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="4ac28-278">[종속성 주입](xref:fundamentals/dependency-injection) 에서 *공유* 메모리 캐시를 사용 하 고, 또는를 호출 하 여 `SetSize` `Size` `SizeLimit` 캐시 크기를 제한 하면 앱에 오류가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-278">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="4ac28-279">캐시에 크기 제한이 설정 된 경우 모든 항목은 추가 될 때 크기를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-279">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="4ac28-280">이로 인해 개발자가 공유 캐시를 사용 하는 항목을 완전히 제어할 수 없기 때문에 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-280">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="4ac28-281">예를 들어 Entity Framework Core는 공유 캐시를 사용 하 고 크기를 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-281">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="4ac28-282">앱이 캐시 크기 제한을 설정 하 고 EF Core를 사용 하는 경우 앱은을 throw `InvalidOperationException` 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-282">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="4ac28-283">, 또는를 사용 하 여 `SetSize` `Size` `SizeLimit` 캐시를 제한 하는 경우 캐싱에 대 한 캐시 singleton을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-283">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="4ac28-284">자세한 내용 및 예제는 [SetSize, Size 및 SizeLimit를 사용 하 여 캐시 크기 제한](#use-setsize-size-and-sizelimit-to-limit-cache-size)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ac28-284">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="4ac28-285">메모리 내 캐싱은 [종속성 주입](../../fundamentals/dependency-injection.md)을 사용 하 여 앱에서 참조 되는 *서비스* 입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-285">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="4ac28-286">`AddMemoryCache`에서 호출 `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="4ac28-286">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="4ac28-287">`IMemoryCache`생성자에서 인스턴스를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-287">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="4ac28-288">`IMemoryCache`[AspNetCore 메타 패키지](xref:fundamentals/metapackage-app)에서 사용할 수 있는 [NuGet 패키지를](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)설치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-288">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="4ac28-289">다음 코드에서는 [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) 를 사용 하 여 시간이 캐시에 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-289">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="4ac28-290">시간이 캐시 되지 않으면 새 항목이 만들어지고 [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_)을 사용 하 여 캐시에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-290">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="4ac28-291">현재 시간과 캐시 된 시간이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-291">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="4ac28-292">`DateTime`제한 시간 내에 요청이 있는 동안 캐시 된 값은 캐시에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-292">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="4ac28-293">다음 이미지는 현재 시간과 캐시에서 검색 된 이전 시간을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-293">The following image shows the current time and an older time retrieved from the cache:</span></span>

![서로 다른 두 시간이 표시 된 인덱스 뷰](memory/_static/time.png)

<span data-ttu-id="4ac28-295">다음 코드는 [Getorcreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) 및 [Getorcreateasync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) 를 사용 하 여 데이터를 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-295">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="4ac28-296">다음 코드는 [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) 을 호출 하 여 캐시 된 시간을 인출 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-296">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="4ac28-297"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> 및 [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) 은의 기능을 확장 하는 [cacheextensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) 클래스의 일부인 확장 메서드입니다 <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="4ac28-297"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="4ac28-298">다른 캐시 메서드에 대 한 설명은 [IMemoryCache 메서드](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) 및 [cacheextensions 메서드](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ac28-298">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="4ac28-299">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="4ac28-299">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="4ac28-300">다음 샘플입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-300">The following sample:</span></span>

* <span data-ttu-id="4ac28-301">슬라이딩 만료 시간을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-301">Sets a sliding expiration time.</span></span> <span data-ttu-id="4ac28-302">이 캐시 된 항목에 액세스 하는 요청은 슬라이딩 만료 시간을 다시 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-302">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="4ac28-303">캐시 우선 순위를로 설정 합니다 `CacheItemPriority.NeverRemove` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-303">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="4ac28-304">항목이 캐시에서 제거 된 후에 호출 되는 [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) 을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-304">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="4ac28-305">콜백은 캐시에서 항목을 제거 하는 코드와 다른 스레드에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-305">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="4ac28-306">SetSize, Size 및 SizeLimit를 사용 하 여 캐시 크기 제한</span><span class="sxs-lookup"><span data-stu-id="4ac28-306">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="4ac28-307">`MemoryCache`인스턴스는 필요에 따라 크기 제한을 지정 하 고 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-307">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="4ac28-308">캐시 크기 제한에는 항목의 크기를 측정 하는 메커니즘이 없기 때문에 정의 된 측정 단위가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-308">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="4ac28-309">캐시 크기 제한이 설정 된 경우 모든 항목의 크기를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-309">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="4ac28-310">ASP.NET Core 런타임은 메모리 압력에 따라 캐시 크기를 제한 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-310">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="4ac28-311">캐시 크기를 제한 하는 것은 개발자에 게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-311">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="4ac28-312">지정 된 크기는 개발자가 선택 하는 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-312">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="4ac28-313">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-313">For example:</span></span>

* <span data-ttu-id="4ac28-314">웹 앱이 주로 문자열을 캐싱하는 경우 각 캐시 엔트리 크기는 문자열 길이가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-314">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="4ac28-315">앱은 모든 항목의 크기를 1로 지정 하 고, 크기 제한은 항목 수를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-315">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="4ac28-316"><xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit>가 설정 되지 않은 경우 캐시는 바인딩되지 않고 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-316">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="4ac28-317">시스템 메모리가 부족할 때 ASP.NET Core 런타임은 캐시를 자르지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-317">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="4ac28-318">앱은 다음에 맞게 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-318">Apps much be architected to:</span></span>

* <span data-ttu-id="4ac28-319">캐시 증가를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-319">Limit cache growth.</span></span>
* <span data-ttu-id="4ac28-320"><xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*>또는 <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> 사용 가능한 메모리가 제한 된 경우를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-320">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="4ac28-321">다음 코드는 <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> [종속성 주입](xref:fundamentals/dependency-injection)을 통해 액세스할 수 있는 고정 크기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-321">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="4ac28-322">`SizeLimit` 에 단위가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-322">`SizeLimit` does not have units.</span></span> <span data-ttu-id="4ac28-323">캐시 된 항목은 캐시 크기 한도가 설정 된 경우 가장 적합 한 모든 단위에서 크기를 지정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-323">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="4ac28-324">캐시 인스턴스의 모든 사용자는 동일한 단위 시스템을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-324">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="4ac28-325">캐시 된 항목 크기의 합계가에 지정 된 값을 초과 하는 경우 항목이 캐시 되지 않습니다 `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-325">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="4ac28-326">캐시 크기 제한을 설정 하지 않으면 항목에 설정 된 캐시 크기가 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-326">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="4ac28-327">다음 코드는 `MyMemoryCache` [종속성 주입](xref:fundamentals/dependency-injection) 컨테이너에 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-327">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="4ac28-328">`MyMemoryCache` 는이 크기 제한 된 캐시를 인식 하는 구성 요소에 대 한 독립 메모리 캐시로 만들어지며 캐시 엔트리 크기를 적절 하 게 설정 하는 방법을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-328">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="4ac28-329">다음 코드에서는를 사용 합니다 `MyMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="4ac28-329">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="4ac28-330">캐시 엔트리의 크기는 [크기](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) 또는 [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) 확장 메서드를 통해 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-330">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="4ac28-331">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="4ac28-331">MemoryCache.Compact</span></span>

<span data-ttu-id="4ac28-332">`MemoryCache.Compact` 다음 순서에 따라 캐시의 지정 된 비율을 제거 하려고 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-332">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="4ac28-333">만료 된 모든 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-333">All expired items.</span></span>
* <span data-ttu-id="4ac28-334">우선 순위별로 항목</span><span class="sxs-lookup"><span data-stu-id="4ac28-334">Items by priority.</span></span> <span data-ttu-id="4ac28-335">우선 순위가 가장 낮은 항목이 먼저 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-335">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="4ac28-336">가장 최근에 사용한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-336">Least recently used objects.</span></span>
* <span data-ttu-id="4ac28-337">가장 빠른 절대 만료를 가진 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-337">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="4ac28-338">가장 빠른 슬라이딩 만료를 포함 하는 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-338">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="4ac28-339">우선 순위가 있는 고정 된 항목 <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> 은 제거 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-339">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="4ac28-340">자세한 내용은 [GitHub의 Compact source](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) 를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="4ac28-340">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="4ac28-341">캐시 종속성</span><span class="sxs-lookup"><span data-stu-id="4ac28-341">Cache dependencies</span></span>

<span data-ttu-id="4ac28-342">다음 샘플에서는 종속 항목이 만료 된 경우 캐시 항목을 만료 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-342">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="4ac28-343"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>이 캐시 된 항목에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-343">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="4ac28-344">`Cancel`에 대해를 호출 하면 `CancellationTokenSource` 두 캐시 항목이 모두 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-344">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="4ac28-345">를 사용 `CancellationTokenSource` 하면 여러 캐시 항목을 하나의 그룹으로 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-345">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="4ac28-346">`using`위의 코드에서 패턴을 사용 하 여 블록 내에 만들어진 캐시 항목 `using` 은 트리거와 만료 설정을 상속 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-346">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="4ac28-347">추가 참고 사항</span><span class="sxs-lookup"><span data-stu-id="4ac28-347">Additional notes</span></span>

* <span data-ttu-id="4ac28-348">콜백을 사용 하 여 캐시 항목을 다시 채우는 경우:</span><span class="sxs-lookup"><span data-stu-id="4ac28-348">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="4ac28-349">콜백이 완료 되지 않아 여러 요청에서 캐시 된 키 값이 비어 있는 것을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-349">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="4ac28-350">이로 인해 여러 스레드가 캐시 된 항목을 늘이기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-350">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="4ac28-351">한 캐시 엔트리를 사용 하 여 다른 캐시 엔트리를 만드는 경우 자식는 부모 항목의 만료 토큰 및 시간 기반 만료 설정을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-351">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="4ac28-352">자식은 수동으로 제거 하거나 부모 항목을 업데이트 하 여 만료 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-352">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="4ac28-353">[PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) 를 사용 하 여 캐시 엔트리를 캐시에서 제거한 후에 발생 하는 콜백을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-353">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="4ac28-354">백그라운드 캐시 업데이트</span><span class="sxs-lookup"><span data-stu-id="4ac28-354">Background cache update</span></span>

<span data-ttu-id="4ac28-355">과 같은 [백그라운드 서비스](xref:fundamentals/host/hosted-services) 를 사용 <xref:Microsoft.Extensions.Hosting.IHostedService> 하 여 캐시를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-355">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="4ac28-356">백그라운드 서비스는 항목을 다시 계산 하 고 준비 된 경우에만 캐시에 할당할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4ac28-356">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="4ac28-357">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="4ac28-357">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
